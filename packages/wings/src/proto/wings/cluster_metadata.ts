// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.0
//   protoc               unknown
// source: wings/cluster_metadata.proto

/* eslint-disable */
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import _m0 from "protobufjs/minimal.js";
import { Empty } from "../google/protobuf/empty.js";

export const protobufPackage = "wings.v1.cluster_metadata";

export interface CreateTenantRequest {
  /** The tenant id. */
  readonly tenantId: string;
  /** The tenant metadata. */
  readonly tenant: Tenant | undefined;
}

export interface GetTenantRequest {
  /**
   * The tenant name.
   *
   * Format: tenants/{tenant}
   */
  readonly name: string;
}

export interface ListTenantsRequest {
  /**
   * The number of tenants to return.
   *
   * Default: 100
   * Maximum: 1000.
   */
  readonly pageSize?:
    | number
    | undefined;
  /** The continuation token. */
  readonly pageToken?: string | undefined;
}

export interface ListTenantsResponse {
  /** The tenants. */
  readonly tenants: readonly Tenant[];
  /** The continuation token. */
  readonly nextPageToken: string;
}

export interface DeleteTenantRequest {
  /**
   * The tenant name.
   *
   * Format: tenants/{tenant}
   */
  readonly name: string;
}

export interface Tenant {
  /**
   * The tenant name.
   *
   * Format: tenants/{tenant}
   */
  readonly name: string;
}

export interface CreateNamespaceRequest {
  /**
   * The tenant that owns the namespace.
   *
   * Format: tenants/{tenant}
   */
  readonly parent: string;
  /** The namespace id. */
  readonly namespaceId: string;
  /** The namespace metadata. */
  readonly namespace: Namespace | undefined;
}

export interface GetNamespaceRequest {
  /**
   * The namespace name.
   *
   * Format: tenants/{tenant}/namespaces/{namespace}
   */
  readonly name: string;
}

export interface ListNamespacesRequest {
  /**
   * The parent tenant.
   *
   * Format: tenants/{tenant}
   */
  readonly parent: string;
  /**
   * The number of namespaces to return.
   *
   * Default: 100
   * Maximum: 1000.
   */
  readonly pageSize?:
    | number
    | undefined;
  /** The continuation token. */
  readonly pageToken?: string | undefined;
}

export interface ListNamespacesResponse {
  /** The namespaces. */
  readonly namespaces: readonly Namespace[];
  /** The continuation token. */
  readonly nextPageToken: string;
}

export interface DeleteNamespaceRequest {
  /**
   * The namespace name.
   *
   * Format: tenants/{tenant}/namespaces/{namespace}
   */
  readonly name: string;
}

export interface Namespace {
  /**
   * The namespace name.
   *
   * Format: tenants/{tenant}/namespaces/{namespace}
   */
  readonly name: string;
  /** The size at which the current segment is flushed to object storage. */
  readonly flushSizeBytes: bigint;
  /** The maximum interval at which the current segment is flushed to object storage (in milliseconds). */
  readonly flushIntervalMillis: bigint;
  /** The default object store configuration for the namespace. */
  readonly defaultObjectStoreConfig: string;
  /** If specified, use this configuration for frozen data. */
  readonly frozenObjectStoreConfig?: string | undefined;
}

export interface CreateTopicRequest {
  /**
   * The namespace that owns the topic.
   *
   * Format: tenants/{tenant}/namespaces/{namespace}
   */
  readonly parent: string;
  /** The topic id. */
  readonly topicId: string;
  /** The topic metadata. */
  readonly topic: Topic | undefined;
}

export interface GetTopicRequest {
  /**
   * The topic name.
   *
   * Format: tenants/{tenant}/namespaces/{namespace}/topics/{topic}
   */
  readonly name: string;
}

export interface ListTopicsRequest {
  /**
   * The parent namespace.
   *
   * Format: tenants/{tenant}/namespaces/{namespace}
   */
  readonly parent: string;
  /**
   * The number of topics to return.
   *
   * Default: 100
   * Maximum: 1000.
   */
  readonly pageSize?:
    | number
    | undefined;
  /** The continuation token. */
  readonly pageToken?: string | undefined;
}

export interface ListTopicsResponse {
  /** The topics. */
  readonly topics: readonly Topic[];
  /** The continuation token. */
  readonly nextPageToken: string;
}

export interface DeleteTopicRequest {
  /**
   * The topic name.
   *
   * Format: tenants/{tenant}/namespaces/{namespace}/topics/{topic}
   */
  readonly name: string;
  /** If set to true, also delete data associated with the topic. */
  readonly force: boolean;
}

export interface Topic {
  /**
   * The topic name.
   *
   * Format: tenants/{tenant}/namespaces/{namespace}/topics/{topic}
   */
  readonly name: string;
  /** The fields in the topic messages. */
  readonly fields: Uint8Array;
  /** The index of the field that is used to partition the topic. */
  readonly partitionKey?: number | undefined;
}

function createBaseCreateTenantRequest(): CreateTenantRequest {
  return { tenantId: "", tenant: undefined };
}

export const CreateTenantRequest = {
  encode(message: CreateTenantRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tenantId !== "") {
      writer.uint32(10).string(message.tenantId);
    }
    if (message.tenant !== undefined) {
      Tenant.encode(message.tenant, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateTenantRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTenantRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tenantId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tenant = Tenant.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTenantRequest {
    return {
      tenantId: isSet(object.tenantId) ? globalThis.String(object.tenantId) : "",
      tenant: isSet(object.tenant) ? Tenant.fromJSON(object.tenant) : undefined,
    };
  },

  toJSON(message: CreateTenantRequest): unknown {
    const obj: any = {};
    if (message.tenantId !== "") {
      obj.tenantId = message.tenantId;
    }
    if (message.tenant !== undefined) {
      obj.tenant = Tenant.toJSON(message.tenant);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateTenantRequest>, I>>(base?: I): CreateTenantRequest {
    return CreateTenantRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateTenantRequest>, I>>(object: I): CreateTenantRequest {
    const message = createBaseCreateTenantRequest() as any;
    message.tenantId = object.tenantId ?? "";
    message.tenant = (object.tenant !== undefined && object.tenant !== null)
      ? Tenant.fromPartial(object.tenant)
      : undefined;
    return message;
  },
};

function createBaseGetTenantRequest(): GetTenantRequest {
  return { name: "" };
}

export const GetTenantRequest = {
  encode(message: GetTenantRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTenantRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTenantRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTenantRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetTenantRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTenantRequest>, I>>(base?: I): GetTenantRequest {
    return GetTenantRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTenantRequest>, I>>(object: I): GetTenantRequest {
    const message = createBaseGetTenantRequest() as any;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListTenantsRequest(): ListTenantsRequest {
  return { pageSize: undefined, pageToken: undefined };
}

export const ListTenantsRequest = {
  encode(message: ListTenantsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pageSize !== undefined) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      writer.uint32(18).string(message.pageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListTenantsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTenantsRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTenantsRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : undefined,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : undefined,
    };
  },

  toJSON(message: ListTenantsRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTenantsRequest>, I>>(base?: I): ListTenantsRequest {
    return ListTenantsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTenantsRequest>, I>>(object: I): ListTenantsRequest {
    const message = createBaseListTenantsRequest() as any;
    message.pageSize = object.pageSize ?? undefined;
    message.pageToken = object.pageToken ?? undefined;
    return message;
  },
};

function createBaseListTenantsResponse(): ListTenantsResponse {
  return { tenants: [], nextPageToken: "" };
}

export const ListTenantsResponse = {
  encode(message: ListTenantsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.tenants) {
      Tenant.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListTenantsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTenantsResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tenants.push(Tenant.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTenantsResponse {
    return {
      tenants: globalThis.Array.isArray(object?.tenants) ? object.tenants.map((e: any) => Tenant.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListTenantsResponse): unknown {
    const obj: any = {};
    if (message.tenants?.length) {
      obj.tenants = message.tenants.map((e) => Tenant.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTenantsResponse>, I>>(base?: I): ListTenantsResponse {
    return ListTenantsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTenantsResponse>, I>>(object: I): ListTenantsResponse {
    const message = createBaseListTenantsResponse() as any;
    message.tenants = object.tenants?.map((e) => Tenant.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseDeleteTenantRequest(): DeleteTenantRequest {
  return { name: "" };
}

export const DeleteTenantRequest = {
  encode(message: DeleteTenantRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteTenantRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTenantRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTenantRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteTenantRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteTenantRequest>, I>>(base?: I): DeleteTenantRequest {
    return DeleteTenantRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteTenantRequest>, I>>(object: I): DeleteTenantRequest {
    const message = createBaseDeleteTenantRequest() as any;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseTenant(): Tenant {
  return { name: "" };
}

export const Tenant = {
  encode(message: Tenant, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Tenant {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTenant() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tenant {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: Tenant): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Tenant>, I>>(base?: I): Tenant {
    return Tenant.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Tenant>, I>>(object: I): Tenant {
    const message = createBaseTenant() as any;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateNamespaceRequest(): CreateNamespaceRequest {
  return { parent: "", namespaceId: "", namespace: undefined };
}

export const CreateNamespaceRequest = {
  encode(message: CreateNamespaceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.namespaceId !== "") {
      writer.uint32(18).string(message.namespaceId);
    }
    if (message.namespace !== undefined) {
      Namespace.encode(message.namespace, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateNamespaceRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateNamespaceRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.namespaceId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.namespace = Namespace.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateNamespaceRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      namespaceId: isSet(object.namespaceId) ? globalThis.String(object.namespaceId) : "",
      namespace: isSet(object.namespace) ? Namespace.fromJSON(object.namespace) : undefined,
    };
  },

  toJSON(message: CreateNamespaceRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.namespaceId !== "") {
      obj.namespaceId = message.namespaceId;
    }
    if (message.namespace !== undefined) {
      obj.namespace = Namespace.toJSON(message.namespace);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateNamespaceRequest>, I>>(base?: I): CreateNamespaceRequest {
    return CreateNamespaceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateNamespaceRequest>, I>>(object: I): CreateNamespaceRequest {
    const message = createBaseCreateNamespaceRequest() as any;
    message.parent = object.parent ?? "";
    message.namespaceId = object.namespaceId ?? "";
    message.namespace = (object.namespace !== undefined && object.namespace !== null)
      ? Namespace.fromPartial(object.namespace)
      : undefined;
    return message;
  },
};

function createBaseGetNamespaceRequest(): GetNamespaceRequest {
  return { name: "" };
}

export const GetNamespaceRequest = {
  encode(message: GetNamespaceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetNamespaceRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNamespaceRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNamespaceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetNamespaceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNamespaceRequest>, I>>(base?: I): GetNamespaceRequest {
    return GetNamespaceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNamespaceRequest>, I>>(object: I): GetNamespaceRequest {
    const message = createBaseGetNamespaceRequest() as any;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListNamespacesRequest(): ListNamespacesRequest {
  return { parent: "", pageSize: undefined, pageToken: undefined };
}

export const ListNamespacesRequest = {
  encode(message: ListNamespacesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== undefined) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListNamespacesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNamespacesRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNamespacesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : undefined,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : undefined,
    };
  },

  toJSON(message: ListNamespacesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListNamespacesRequest>, I>>(base?: I): ListNamespacesRequest {
    return ListNamespacesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListNamespacesRequest>, I>>(object: I): ListNamespacesRequest {
    const message = createBaseListNamespacesRequest() as any;
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? undefined;
    message.pageToken = object.pageToken ?? undefined;
    return message;
  },
};

function createBaseListNamespacesResponse(): ListNamespacesResponse {
  return { namespaces: [], nextPageToken: "" };
}

export const ListNamespacesResponse = {
  encode(message: ListNamespacesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.namespaces) {
      Namespace.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListNamespacesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNamespacesResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.namespaces.push(Namespace.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNamespacesResponse {
    return {
      namespaces: globalThis.Array.isArray(object?.namespaces)
        ? object.namespaces.map((e: any) => Namespace.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListNamespacesResponse): unknown {
    const obj: any = {};
    if (message.namespaces?.length) {
      obj.namespaces = message.namespaces.map((e) => Namespace.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListNamespacesResponse>, I>>(base?: I): ListNamespacesResponse {
    return ListNamespacesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListNamespacesResponse>, I>>(object: I): ListNamespacesResponse {
    const message = createBaseListNamespacesResponse() as any;
    message.namespaces = object.namespaces?.map((e) => Namespace.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseDeleteNamespaceRequest(): DeleteNamespaceRequest {
  return { name: "" };
}

export const DeleteNamespaceRequest = {
  encode(message: DeleteNamespaceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteNamespaceRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteNamespaceRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteNamespaceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteNamespaceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteNamespaceRequest>, I>>(base?: I): DeleteNamespaceRequest {
    return DeleteNamespaceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteNamespaceRequest>, I>>(object: I): DeleteNamespaceRequest {
    const message = createBaseDeleteNamespaceRequest() as any;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseNamespace(): Namespace {
  return {
    name: "",
    flushSizeBytes: BigInt("0"),
    flushIntervalMillis: BigInt("0"),
    defaultObjectStoreConfig: "",
    frozenObjectStoreConfig: undefined,
  };
}

export const Namespace = {
  encode(message: Namespace, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.flushSizeBytes !== BigInt("0")) {
      if (BigInt.asUintN(64, message.flushSizeBytes) !== message.flushSizeBytes) {
        throw new globalThis.Error("value provided for field message.flushSizeBytes of type uint64 too large");
      }
      writer.uint32(16).uint64(message.flushSizeBytes.toString());
    }
    if (message.flushIntervalMillis !== BigInt("0")) {
      if (BigInt.asUintN(64, message.flushIntervalMillis) !== message.flushIntervalMillis) {
        throw new globalThis.Error("value provided for field message.flushIntervalMillis of type uint64 too large");
      }
      writer.uint32(24).uint64(message.flushIntervalMillis.toString());
    }
    if (message.defaultObjectStoreConfig !== "") {
      writer.uint32(34).string(message.defaultObjectStoreConfig);
    }
    if (message.frozenObjectStoreConfig !== undefined) {
      writer.uint32(42).string(message.frozenObjectStoreConfig);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Namespace {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamespace() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.flushSizeBytes = longToBigint(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.flushIntervalMillis = longToBigint(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.defaultObjectStoreConfig = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.frozenObjectStoreConfig = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Namespace {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      flushSizeBytes: isSet(object.flushSizeBytes) ? BigInt(object.flushSizeBytes) : BigInt("0"),
      flushIntervalMillis: isSet(object.flushIntervalMillis) ? BigInt(object.flushIntervalMillis) : BigInt("0"),
      defaultObjectStoreConfig: isSet(object.defaultObjectStoreConfig)
        ? globalThis.String(object.defaultObjectStoreConfig)
        : "",
      frozenObjectStoreConfig: isSet(object.frozenObjectStoreConfig)
        ? globalThis.String(object.frozenObjectStoreConfig)
        : undefined,
    };
  },

  toJSON(message: Namespace): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.flushSizeBytes !== BigInt("0")) {
      obj.flushSizeBytes = message.flushSizeBytes.toString();
    }
    if (message.flushIntervalMillis !== BigInt("0")) {
      obj.flushIntervalMillis = message.flushIntervalMillis.toString();
    }
    if (message.defaultObjectStoreConfig !== "") {
      obj.defaultObjectStoreConfig = message.defaultObjectStoreConfig;
    }
    if (message.frozenObjectStoreConfig !== undefined) {
      obj.frozenObjectStoreConfig = message.frozenObjectStoreConfig;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Namespace>, I>>(base?: I): Namespace {
    return Namespace.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Namespace>, I>>(object: I): Namespace {
    const message = createBaseNamespace() as any;
    message.name = object.name ?? "";
    message.flushSizeBytes = object.flushSizeBytes ?? BigInt("0");
    message.flushIntervalMillis = object.flushIntervalMillis ?? BigInt("0");
    message.defaultObjectStoreConfig = object.defaultObjectStoreConfig ?? "";
    message.frozenObjectStoreConfig = object.frozenObjectStoreConfig ?? undefined;
    return message;
  },
};

function createBaseCreateTopicRequest(): CreateTopicRequest {
  return { parent: "", topicId: "", topic: undefined };
}

export const CreateTopicRequest = {
  encode(message: CreateTopicRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.topicId !== "") {
      writer.uint32(18).string(message.topicId);
    }
    if (message.topic !== undefined) {
      Topic.encode(message.topic, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateTopicRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTopicRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.topicId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.topic = Topic.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTopicRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "",
      topic: isSet(object.topic) ? Topic.fromJSON(object.topic) : undefined,
    };
  },

  toJSON(message: CreateTopicRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.topicId !== "") {
      obj.topicId = message.topicId;
    }
    if (message.topic !== undefined) {
      obj.topic = Topic.toJSON(message.topic);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateTopicRequest>, I>>(base?: I): CreateTopicRequest {
    return CreateTopicRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateTopicRequest>, I>>(object: I): CreateTopicRequest {
    const message = createBaseCreateTopicRequest() as any;
    message.parent = object.parent ?? "";
    message.topicId = object.topicId ?? "";
    message.topic = (object.topic !== undefined && object.topic !== null) ? Topic.fromPartial(object.topic) : undefined;
    return message;
  },
};

function createBaseGetTopicRequest(): GetTopicRequest {
  return { name: "" };
}

export const GetTopicRequest = {
  encode(message: GetTopicRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTopicRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTopicRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTopicRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetTopicRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTopicRequest>, I>>(base?: I): GetTopicRequest {
    return GetTopicRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTopicRequest>, I>>(object: I): GetTopicRequest {
    const message = createBaseGetTopicRequest() as any;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListTopicsRequest(): ListTopicsRequest {
  return { parent: "", pageSize: undefined, pageToken: undefined };
}

export const ListTopicsRequest = {
  encode(message: ListTopicsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== undefined) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListTopicsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTopicsRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTopicsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : undefined,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : undefined,
    };
  },

  toJSON(message: ListTopicsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTopicsRequest>, I>>(base?: I): ListTopicsRequest {
    return ListTopicsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTopicsRequest>, I>>(object: I): ListTopicsRequest {
    const message = createBaseListTopicsRequest() as any;
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? undefined;
    message.pageToken = object.pageToken ?? undefined;
    return message;
  },
};

function createBaseListTopicsResponse(): ListTopicsResponse {
  return { topics: [], nextPageToken: "" };
}

export const ListTopicsResponse = {
  encode(message: ListTopicsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.topics) {
      Topic.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListTopicsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTopicsResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topics.push(Topic.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTopicsResponse {
    return {
      topics: globalThis.Array.isArray(object?.topics) ? object.topics.map((e: any) => Topic.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListTopicsResponse): unknown {
    const obj: any = {};
    if (message.topics?.length) {
      obj.topics = message.topics.map((e) => Topic.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTopicsResponse>, I>>(base?: I): ListTopicsResponse {
    return ListTopicsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTopicsResponse>, I>>(object: I): ListTopicsResponse {
    const message = createBaseListTopicsResponse() as any;
    message.topics = object.topics?.map((e) => Topic.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseDeleteTopicRequest(): DeleteTopicRequest {
  return { name: "", force: false };
}

export const DeleteTopicRequest = {
  encode(message: DeleteTopicRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.force !== false) {
      writer.uint32(16).bool(message.force);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteTopicRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTopicRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.force = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTopicRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: DeleteTopicRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteTopicRequest>, I>>(base?: I): DeleteTopicRequest {
    return DeleteTopicRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteTopicRequest>, I>>(object: I): DeleteTopicRequest {
    const message = createBaseDeleteTopicRequest() as any;
    message.name = object.name ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

function createBaseTopic(): Topic {
  return { name: "", fields: new Uint8Array(0), partitionKey: undefined };
}

export const Topic = {
  encode(message: Topic, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.fields.length !== 0) {
      writer.uint32(18).bytes(message.fields);
    }
    if (message.partitionKey !== undefined) {
      writer.uint32(24).uint32(message.partitionKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Topic {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopic() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fields = reader.bytes();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.partitionKey = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Topic {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      fields: isSet(object.fields) ? bytesFromBase64(object.fields) : new Uint8Array(0),
      partitionKey: isSet(object.partitionKey) ? globalThis.Number(object.partitionKey) : undefined,
    };
  },

  toJSON(message: Topic): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.fields.length !== 0) {
      obj.fields = base64FromBytes(message.fields);
    }
    if (message.partitionKey !== undefined) {
      obj.partitionKey = Math.round(message.partitionKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Topic>, I>>(base?: I): Topic {
    return Topic.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Topic>, I>>(object: I): Topic {
    const message = createBaseTopic() as any;
    message.name = object.name ?? "";
    message.fields = object.fields ?? new Uint8Array(0);
    message.partitionKey = object.partitionKey ?? undefined;
    return message;
  },
};

/** Cluster metadata service to manage cluster resources. */
export type ClusterMetadataServiceDefinition = typeof ClusterMetadataServiceDefinition;
export const ClusterMetadataServiceDefinition = {
  name: "ClusterMetadataService",
  fullName: "wings.v1.cluster_metadata.ClusterMetadataService",
  methods: {
    /** Create a new tenant. */
    createTenant: {
      name: "CreateTenant",
      requestType: CreateTenantRequest,
      requestStream: false,
      responseType: Tenant,
      responseStream: false,
      options: {},
    },
    /** Return the specified tenant. */
    getTenant: {
      name: "GetTenant",
      requestType: GetTenantRequest,
      requestStream: false,
      responseType: Tenant,
      responseStream: false,
      options: {},
    },
    /** List all tenants. */
    listTenants: {
      name: "ListTenants",
      requestType: ListTenantsRequest,
      requestStream: false,
      responseType: ListTenantsResponse,
      responseStream: false,
      options: {},
    },
    /**
     * Delete a tenant.
     *
     * The request fails if the tenant has any namespace.
     */
    deleteTenant: {
      name: "DeleteTenant",
      requestType: DeleteTenantRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Create a new namespace belonging to a tenant. */
    createNamespace: {
      name: "CreateNamespace",
      requestType: CreateNamespaceRequest,
      requestStream: false,
      responseType: Namespace,
      responseStream: false,
      options: {},
    },
    /** Return the specified namespace. */
    getNamespace: {
      name: "GetNamespace",
      requestType: GetNamespaceRequest,
      requestStream: false,
      responseType: Namespace,
      responseStream: false,
      options: {},
    },
    /** List all namespaces belonging to a tenant. */
    listNamespaces: {
      name: "ListNamespaces",
      requestType: ListNamespacesRequest,
      requestStream: false,
      responseType: ListNamespacesResponse,
      responseStream: false,
      options: {},
    },
    /**
     * Delete a namespace.
     *
     * The request fails if the namespace has any topic.
     */
    deleteNamespace: {
      name: "DeleteNamespace",
      requestType: DeleteNamespaceRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Create a new topic belonging to a namespace. */
    createTopic: {
      name: "CreateTopic",
      requestType: CreateTopicRequest,
      requestStream: false,
      responseType: Topic,
      responseStream: false,
      options: {},
    },
    /** Return the specified topic. */
    getTopic: {
      name: "GetTopic",
      requestType: GetTopicRequest,
      requestStream: false,
      responseType: Topic,
      responseStream: false,
      options: {},
    },
    /** List all topics belonging to a namespace. */
    listTopics: {
      name: "ListTopics",
      requestType: ListTopicsRequest,
      requestStream: false,
      responseType: ListTopicsResponse,
      responseStream: false,
      options: {},
    },
    /** Delete a topic. */
    deleteTopic: {
      name: "DeleteTopic",
      requestType: DeleteTopicRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface ClusterMetadataServiceImplementation<CallContextExt = {}> {
  /** Create a new tenant. */
  createTenant(request: CreateTenantRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Tenant>>;
  /** Return the specified tenant. */
  getTenant(request: GetTenantRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Tenant>>;
  /** List all tenants. */
  listTenants(
    request: ListTenantsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListTenantsResponse>>;
  /**
   * Delete a tenant.
   *
   * The request fails if the tenant has any namespace.
   */
  deleteTenant(request: DeleteTenantRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Create a new namespace belonging to a tenant. */
  createNamespace(
    request: CreateNamespaceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Namespace>>;
  /** Return the specified namespace. */
  getNamespace(request: GetNamespaceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Namespace>>;
  /** List all namespaces belonging to a tenant. */
  listNamespaces(
    request: ListNamespacesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListNamespacesResponse>>;
  /**
   * Delete a namespace.
   *
   * The request fails if the namespace has any topic.
   */
  deleteNamespace(request: DeleteNamespaceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Create a new topic belonging to a namespace. */
  createTopic(request: CreateTopicRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Topic>>;
  /** Return the specified topic. */
  getTopic(request: GetTopicRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Topic>>;
  /** List all topics belonging to a namespace. */
  listTopics(
    request: ListTopicsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListTopicsResponse>>;
  /** Delete a topic. */
  deleteTopic(request: DeleteTopicRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
}

export interface ClusterMetadataServiceClient<CallOptionsExt = {}> {
  /** Create a new tenant. */
  createTenant(request: DeepPartial<CreateTenantRequest>, options?: CallOptions & CallOptionsExt): Promise<Tenant>;
  /** Return the specified tenant. */
  getTenant(request: DeepPartial<GetTenantRequest>, options?: CallOptions & CallOptionsExt): Promise<Tenant>;
  /** List all tenants. */
  listTenants(
    request: DeepPartial<ListTenantsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListTenantsResponse>;
  /**
   * Delete a tenant.
   *
   * The request fails if the tenant has any namespace.
   */
  deleteTenant(request: DeepPartial<DeleteTenantRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Create a new namespace belonging to a tenant. */
  createNamespace(
    request: DeepPartial<CreateNamespaceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Namespace>;
  /** Return the specified namespace. */
  getNamespace(request: DeepPartial<GetNamespaceRequest>, options?: CallOptions & CallOptionsExt): Promise<Namespace>;
  /** List all namespaces belonging to a tenant. */
  listNamespaces(
    request: DeepPartial<ListNamespacesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListNamespacesResponse>;
  /**
   * Delete a namespace.
   *
   * The request fails if the namespace has any topic.
   */
  deleteNamespace(request: DeepPartial<DeleteNamespaceRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Create a new topic belonging to a namespace. */
  createTopic(request: DeepPartial<CreateTopicRequest>, options?: CallOptions & CallOptionsExt): Promise<Topic>;
  /** Return the specified topic. */
  getTopic(request: DeepPartial<GetTopicRequest>, options?: CallOptions & CallOptionsExt): Promise<Topic>;
  /** List all topics belonging to a namespace. */
  listTopics(
    request: DeepPartial<ListTopicsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListTopicsResponse>;
  /** Delete a topic. */
  deleteTopic(request: DeepPartial<DeleteTopicRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { readonly $case: string }
    ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { readonly $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToBigint(long: Long) {
  return BigInt(long.toString());
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
